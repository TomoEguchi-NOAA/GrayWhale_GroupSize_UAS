---
title: "Group size calibration using UAS"
format: docx
editor: visual
---

```{r}
rm(list = ls())
library(tidyverse)
library(ggplot2)
library(ggridges)
```

## Modeling Group Size Observations

Determining the group size of gray whales from shore-based visual observations is difficult. Sequential breathing of multiple whales might result in an over- or undercount of the number of whales in a group. Aerial observations were used to determine errors associated with estimating group sizes by visual observers.

In this study, we modeled gray whale group size observations from visual observers and UAS (Uncrewed Aircraft System). The goal of this project was to determine the relationship between the true and visually observed group sizes so that the visual counts can be calibrated to the true counts.

Because UAS-based observations were based on video footage from directly above each group, the UAS-based estimated group size was more accurate than that of visual observers, who determined the group size from visual cues (blows). However, only a small proportion of all visually observed groups were also observed via UAS. By modeling the relationship between the visual and UAS-based observations, missing UAS-based observations were estimated.

I used two sets of models to fit the group size observations from the two methods. In one set, UAS-based observed group sizes were treated as the true group sizes. In the other set, UAS-based observations were treated as sampling with errors from unknown group sizes.

After fitting several models within each group, three models were selected for further consideration. This decision was based on qualitative relationships between observed and predicted UAS-based group sizes, relative to visual observations.

### Model 1

This model treats UAS-based observations as random samples from a Gamma distribution:

$$ n^{UAS}_i \sim GAM(2.952, 0.760) $$ These parameter values were obtained by fitting the gamma distribution to UAS-based observed group sizes. Each UAS-based observation was treated as independent sample.

The visual observations were treated as independent Poisson deviates with the mean as a function of various covariates, including the UAS-based observations:

$$ n^{vis}_i \sim POI(\mu^{vis}_i) T(Min(n^{vis}_i), Max(n)) $$ $$log(\mu^{vis}_i) = \beta_0 + \beta_1 * n^{UAS}_i + \beta_2 * Dist_i + \beta_3 * BFT_i + \beta_4 * VIS_i + OBS_i$$

where $Dist_i$ is the distance of the i-th group from the observation station, $BFT_i$ is the Beaufort sea state at the time of the observation, $VIS_i$ is the visibility code at the time of the observation, and $OBS_i$ is the observer. $T(a, b)$ indicates the truncation function with minimum = a and maximum = b. $Min(n^{vis}_i)$ is 1 if no information is available about the group, whereas it is \> 1 if such information is available. $Max(n)$ is the maximum possible group size, which was set at the maximum observed group size plus 5.

### Model 2

This model is similar to the first model except that the covariates were used to determine the detection probability ($p^{vis}_i$).

$$ logit(p^{vis}_i) = \beta_0 + \beta_2 * Dist_i + \beta_3 * BFT_i + \beta_4 * VIS_i + OBS_i   $$ The mean of the Poisson distribution for the visually observed group size ($\mu^{vis}_i$) is computed as

$$ \mu^{vis}_i = n^{UAS}_i * p^{vis}_i $$ UAS-based group sizes are assumed Gamma distributed random deviates as in the first model.

### Model 3

The third model contains a true group size parameter.

$$ N_i \sim GAM(2.925, 0.760) T(Min(n^{vis}_i), Max(n)) $$ Observations from visual observers and UAS are modeled with independent Poisson distributions.

$$ n^{vis}_i \sim POI(\mu^{vis}_i) T(Min(n^{vis}_i), Max(n)) $$

The mean of the Poisson distribution is

$$ \mu^{vis}_i = N_i * p^{vis}_i $$

For the UAS-based observation

$$ n^{UAS}_i \sim POI(\mu^{UAS}_i) T(Min(n^{vis}_i), Max(n)) $$

$$ \mu^{UAS}_i = N_i * p^{UAS}_i $$

Currently, I set $p^{UAS}_i = 1.0$, or all whales in the i-th group were counted from UAS footage.

## Results

All models were run using JAGS in R with the **jagsUI** package. Goodness of fit was determined using the Pareto-k statistic using the **loo** package. Convergence of Markov chain Monte Carlo (MCMC) was determined using the $\hat{R}$ statistic.

```{r}
# 
# 
# Sightings.1 <- read.csv(file = "data/SIGHTINGS_GROUPS_with_ObsIDs.csv")
# 
# uniq.obs.df <- data.frame(OBS_1 = unique(Sightings.1$OBS_1)) %>%
#   mutate(Obs.ID = 1:length(OBS_1))
# 
# Sightings.1 %>% 
#   left_join(uniq.obs.df, by = "OBS_1") -> Sightings
# 
# # Create a new column of minimum group sizes
# Sightings %>%
#   mutate(Group_Size_Min_Vis = GROUP_SIZE_LAST - 2) -> Sightings
# 
# min.group.size.Vis <- Sightings$Group_Size_Min_Vis
# 
# GS.I <- vector(mode = "numeric", length = length(min.group.size.Vis))
# GS.I[!is.na(Sightings$Group_Size)] <- 1
# 
# # Adjust the minimum group size. Minimum group size should be less than
# # the observed 
# #min.group.size[is.na(min.group.size)] <- 1
# min.group.size.Vis[min.group.size.Vis < 1] <- 1
# 
# min.group.size.UAS <- Sightings$Group_Size_Min
# min.group.size.UAS[is.na(min.group.size.UAS)] <- min.group.size.Vis[is.na(min.group.size.UAS)]
# 
# min.group.size.df <- data.frame(UAS = min.group.size.UAS,
#                                 Vis = Sightings$GROUP_SIZE_LAST)
# 
# min.group.size <- apply(min.group.size.df, FUN = max, MARGIN = 1, na.rm = T)
# 
# # group size categories
# GS.cat <- vector(mode = "numeric", length = length(min.group.size))
# GS.cat[Sightings$GROUP_SIZE_LAST < 3] <- 1
# GS.cat[Sightings$GROUP_SIZE_LAST > 2 & Sightings$GROUP_SIZE_LAST < 5] <- 2
# GS.cat[Sightings$GROUP_SIZE_LAST > 4] <- 3
# 
# GS.min <- min.group.size.UAS
# GS.min[which((min.group.size.UAS - min.group.size) < 0)] <- Sightings$GROUP_SIZE_LAST[which((min.group.size.UAS - min.group.size) < 0)]
# 
# jags.data <- list(n.grp = nrow(Sightings),
#                   GS.Vis = Sightings$GROUP_SIZE_LAST,
#                   GS.UAS = Sightings$Group_Size,
#                   Dist = Sightings$DIST_MIN,
#                   Bft = Sightings$BEAUFORT_LAST,
#                   Vis = Sightings$VISIBILITY_LAST,
#                   obs = Sightings$Obs.ID,
#                   GS.min.Vis = min.group.size.Vis,
#                   GS.min.UAS = min.group.size.UAS,
#                   GS.min = min.group.size,
#                   GS.I = GS.I,
#                   GS.max = max(Sightings$Group_Size_Min, na.rm = T) + 5,
#                   GS.cat = GS.cat,
#                   n.obs = nrow(uniq.obs.df))

```

### Model 1

Convergence was reached for all parameters ($Max(\hat{R}) = 1.023$). Pareto-k statistic indicated the model fit well to the data (all Pareto-k statistics \< 0.6). In this model, the parameter of interest is $n^{UAS}$ conditional on visually observed group sizes.

```{r}
plot.ridges <- function(x, levels = c("1", "2", "3", "4", 
                                      "5", "6", "7", "8", 
                                      "9", "12"),
                        bandwidth = 0.12){
  jm.out <- readRDS(x)
  
  n.UAS <- jm.out$jm$sims.list$GS.UAS
  n.Vis <- jm.out$jags.data$GS.Vis
  
  Sightings. <- data.frame(UAS = jm.out$jags.data$GS.UAS,
                            Vis = jm.out$jags.data$GS.Vis) %>%
    na.omit() %>%
    mutate(Vis.f = factor(Vis, levels = levels))
  
  n. <- data.frame(UAS = as.vector(n.UAS),
                   Vis = rep(n.Vis, each = nrow(n.UAS))) %>%
    mutate(Vis.f = factor(Vis, levels = levels))
  
  p.ridges <- ggplot() +
    # geom_density_ridges(data = Sightings.2,
    #                     aes(x = UAS, y = Vis.f)) +
    geom_density_ridges(data = n.,
                        aes(x = UAS, y = Vis.f, fill = Vis.f),
                        bandwidth = bandwidth) +
    geom_jitter(data = Sightings.,
                aes(x = UAS, y = Vis.f, color = Vis.f),
                width = 0) +
    geom_abline(slope = 1.0) +
    theme(legend.position = "none") +
    ylab("Visual group size") +
    xlab("UAS group size")

  out <- list(plot = p.ridges,
              sightings = Sightings.,
              n = n.)  
}

out.v3 <- plot.ridges("RData/jm_out_v3.rds")
out.v3.max6 <- plot.ridges("RData/jm_out_v3_max6.rds",
                           levels = c("1", "2", "3", "4", 
                                      "5", "6"),
                           bandwidth = 0.25)

out.v5 <- plot.ridges("RData/jm_out_v5.rds")
out.v5.max6 <- plot.ridges("RData/jm_out_v5_max6.rds",
                           levels = c("1", "2", "3", "4", 
                                      "5", "6"),
                           bandwidth = 0.25)

plot.ridges.2 <- function(x, levels = c("1", "2", "3", "4", 
                                      "5", "6", "7", "8", 
                                      "9", "12"),
                        bandwidth = 0.12){
  jm.out <- readRDS(x)
  
  n.UAS <- jm.out$jm$sims.list$GS.
  n.Vis <- jm.out$jags.data$GS.Vis
  
  Sightings. <- data.frame(UAS = jm.out$jags.data$GS.UAS,
                            Vis = jm.out$jags.data$GS.Vis) %>%
    na.omit() %>%
    mutate(Vis.f = factor(Vis, levels = levels))
  
  n. <- data.frame(UAS = as.vector(n.UAS),
                   Vis = rep(n.Vis, each = nrow(n.UAS))) %>%
    mutate(Vis.f = factor(Vis, levels = levels))
  
  p.ridges <- ggplot() +
    # geom_density_ridges(data = Sightings.2,
    #                     aes(x = UAS, y = Vis.f)) +
    geom_density_ridges(data = n.,
                        aes(x = UAS, y = Vis.f, fill = Vis.f),
                        bandwidth = bandwidth) +
    geom_jitter(data = Sightings.,
                aes(x = UAS, y = Vis.f, color = Vis.f),
                width = 0) +
    geom_abline(slope = 1.0) +
    theme(legend.position = "none") +
    ylab("Visual group size") +
    xlab("Group size")

  out <- list(plot = p.ridges,
              sightings = Sightings.,
              n = n.)  
}

out.v6 <- plot.ridges.2("RData/jm_out_v6.rds",
                      bandwidth = 0.3)
out.v6.max6 <- plot.ridges.2("RData/jm_out_v6_max6.rds",
                           levels = c("1", "2", "3", "4", 
                                      "5", "6"),
                           bandwidth = 0.25)

```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
